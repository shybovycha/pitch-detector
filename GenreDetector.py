# -*- coding: utf-8 -*-
import numpy as np
from time import gmtime


def nonlin(x, deriv=False):
    if deriv:
        return x * (1 - x)

    return 1 / (1 + np.exp(-x))


X = np.array([
    # crosses
    [0, 1, 0, 0, 1,
     0, 0, 1, 1, 0,
     0, 0, 1, 0, 0,
     0, 1, 0, 1, 0,
     1, 0, 0, 0, 1],

    [0, 0, 0, 0, 0,
     0, 1, 0, 1, 0,
     0, 0, 1, 0, 0,
     0, 1, 0, 1, 0,
     0, 0, 0, 0, 0],

    [0, 1, 0, 1, 0,
     0, 0, 1, 0, 0,
     0, 1, 0, 1, 0,
     0, 0, 0, 0, 0,
     0, 0, 0, 0, 0],

    [0, 0, 1, 0, 1,
     0, 0, 0, 1, 0,
     0, 0, 1, 0, 1,
     0, 0, 0, 0, 0,
     0, 0, 0, 0, 0],

    [0, 0, 0, 0, 0,
     0, 0, 1, 0, 1,
     0, 0, 0, 1, 0,
     0, 0, 1, 0, 1,
     0, 0, 0, 0, 0],

    [0, 0, 0, 0, 0,
     0, 0, 0, 0, 0,
     0, 0, 1, 0, 1,
     0, 0, 0, 1, 0,
     0, 0, 1, 0, 1],

    [0, 0, 0, 0, 0,
     0, 0, 0, 0, 0,
     0, 1, 0, 1, 0,
     0, 0, 1, 0, 0,
     0, 1, 0, 1, 0],

    [0, 0, 0, 0, 0,
     0, 0, 0, 0, 0,
     1, 0, 1, 0, 0,
     0, 1, 0, 0, 0,
     1, 0, 1, 0, 0],

    [0, 0, 0, 0, 0,
     1, 0, 1, 0, 0,
     0, 1, 0, 0, 0,
     1, 0, 1, 0, 0,
     0, 0, 0, 0, 0],

    [0, 0, 0, 0, 0,
     0, 1, 0, 1, 0,
     0, 0, 1, 0, 0,
     0, 1, 0, 1, 0,
     0, 0, 0, 0, 0],

    [1, 0, 1, 0, 0,
     0, 1, 0, 0, 0,
     1, 0, 1, 0, 0,
     0, 0, 0, 0, 0,
     0, 0, 0, 0, 0],

    [1, 0, 0, 0, 1,
     0, 1, 0, 1, 0,
     0, 0, 1, 0, 0,
     0, 1, 0, 1, 0,
     1, 0, 0, 0, 1],

    # rectangle

    [1, 1, 1, 1, 1,
     1, 0, 0, 0, 1,
     1, 0, 0, 0, 1,
     1, 0, 0, 0, 1,
     1, 1, 1, 1, 1],

    # triangles

    [0, 0, 1, 0, 0,
     0, 1, 0, 1, 0,
     1, 1, 1, 1, 1,
     0, 0, 0, 0, 0,
     0, 0, 0, 0, 0],

    [0, 0, 0, 0, 1,
     0, 0, 0, 1, 1,
     0, 0, 1, 0, 1,
     0, 1, 0, 0, 1,
     1, 1, 1, 1, 1],

    [1, 0, 0, 0, 0,
     1, 1, 0, 0, 0,
     1, 0, 1, 0, 0,
     1, 0, 0, 1, 0,
     1, 1, 1, 1, 1],

    [1, 1, 1, 1, 1,
     0, 1, 0, 1, 0,
     0, 0, 1, 0, 0,
     0, 0, 0, 0, 0,
     0, 0, 0, 0, 0],

    [1, 0, 0, 0, 0,
     1, 1, 0, 0, 0,
     1, 0, 1, 0, 0,
     1, 1, 0, 0, 0,
     1, 0, 0, 0, 0],

    [0, 0, 0, 0, 1,
     0, 0, 0, 1, 1,
     0, 0, 1, 0, 1,
     0, 0, 0, 1, 1,
     0, 0, 0, 0, 1],

    [0, 0, 0, 0, 1,
     0, 0, 0, 1, 1,
     0, 0, 1, 0, 1,
     0, 1, 1, 1, 1,
     0, 0, 0, 0, 0],

    [0, 0, 0, 0, 0,
     0, 0, 0, 0, 1,
     0, 0, 0, 1, 1,
     0, 0, 1, 0, 1,
     0, 1, 1, 1, 1],

    [0, 0, 0, 0, 0,
     0, 0, 0, 1, 0,
     0, 0, 1, 1, 0,
     0, 1, 0, 1, 0,
     1, 1, 1, 1, 0],

    [0, 0, 0, 0, 0,
     1, 0, 0, 0, 0,
     1, 1, 0, 0, 0,
     1, 0, 1, 0, 0,
     1, 1, 1, 1, 0],

    [0, 0, 0, 0, 0,
     0, 1, 0, 0, 0,
     0, 1, 1, 0, 0,
     0, 1, 0, 1, 0,
     0, 1, 1, 1, 1]])

Y = np.array([[1, 0, 0],  # cross (X)
              [1, 0, 0],  # cross (X)
              [1, 0, 0],  # cross (X)
              [1, 0, 0],  # cross (X)
              [1, 0, 0],  # cross (X)
              [1, 0, 0],  # cross (X)
              [1, 0, 0],  # cross (X)
              [1, 0, 0],  # cross (X)
              [1, 0, 0],  # cross (X)
              [1, 0, 0],  # cross (X)
              [1, 0, 0],  # cross (X)
              [1, 0, 0],  # cross (X)

              [0, 1, 0],  # square

              [0, 0, 1],  # triangle
              [0, 0, 1],  # triangle
              [0, 0, 1],  # triangle
              [0, 0, 1],  # triangle
              [0, 0, 1],  # triangle
              [0, 0, 1],  # triangle
              [0, 0, 1],  # triangle
              [0, 0, 1],  # triangle
              [0, 0, 1],  # triangle
              [0, 0, 1],  # triangle
              [0, 0, 1]])  # triangle

np.random.seed(1)

# случайно инициализируем веса, в среднем - 0
syn0 = 2 * np.random.random((25, 25)) - 1
syn1 = 2 * np.random.random((25, 12)) - 1
syn2 = 2 * np.random.random((12, 3)) - 1

np.random.seed(gmtime())

indices = np.arange(len(X))

for j in xrange(1500000):
    np.random.shuffle(indices)

    X1 = X[indices]
    Y1 = Y[indices]

    # проходим вперёд по слоям 0, 1 и 2
    l0 = X1
    l1 = nonlin(np.dot(l0, syn0))
    l2 = nonlin(np.dot(l1, syn1))
    l3 = nonlin(np.dot(l2, syn2))

    # как сильно мы ошиблись относительно нужной величины?
    l3_error = Y1 - l3

    if (j % 100000) == 0:
        print "Error:" + str(np.mean(np.abs(l3_error)))

    # в какую сторону нужно двигаться?
    # если мы были уверены в предсказании, то сильно менять его не надо
    l3_delta = l3_error * nonlin(l3, deriv=True)

    # как сильно значения l2 влияют на ошибки в l3?
    l2_error = l3_delta.dot(syn2.T)

    l2_delta = l2_error * nonlin(l2, deriv=True)

    # как сильно значения l1 влияют на ошибки в l2?
    l1_error = l2_delta.dot(syn1.T)

    # в каком направлении нужно двигаться, чтобы прийти к l1?
    # если мы были уверены в предсказании, то сильно менять его не надо
    l1_delta = l1_error * nonlin(l1, deriv=True)

    syn2 += l2.T.dot(l3_delta)
    syn1 += l1.T.dot(l2_delta)
    syn0 += l0.T.dot(l1_delta)

    np.random.seed(gmtime())

X1 = np.array([[0, 0, 0, 1, 0,
                0, 0, 1, 1, 0,
                0, 1, 0, 1, 0,
                1, 1, 1, 1, 0,
                0, 0, 0, 0, 0]])
l0 = X1
l1 = nonlin(np.dot(l0, syn0))
l2 = nonlin(np.dot(l1, syn1))
l3 = nonlin(np.dot(l2, syn2))

np.set_printoptions(precision=4)
print l3
